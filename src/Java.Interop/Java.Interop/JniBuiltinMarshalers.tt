<#@ template  language="C#" #>
<#@ assembly  name="System.Core" #>
<#@ import    namespace="System.Collections.Generic" #>
<#@ import    namespace="System.Linq" #>
<#@ import    namespace="System.Text" #>
using System;
using System.Collections.Generic;
using System.Diagnostics;

namespace Java.Interop {
<#
	var types = new[]{
		new { Name = "Boolean",     Type = "Boolean",   JniType = "Z",  GetValue = "booleanValue" },
		new { Name = "Byte",        Type = "SByte",     JniType = "B",  GetValue = "byteValue" },
		new { Name = "Character",   Type = "Char",      JniType = "C",  GetValue = "charValue" },
		new { Name = "Short",       Type = "Int16",     JniType = "S",  GetValue = "shortValue" },
		new { Name = "Integer",     Type = "Int32",     JniType = "I",  GetValue = "intValue" },
		new { Name = "Long",        Type = "Int64",     JniType = "J",  GetValue = "longValue" },
		new { Name = "Float",       Type = "Single",    JniType = "F",  GetValue = "floatValue" },
		new { Name = "Double",      Type = "Double",    JniType = "D",  GetValue = "doubleValue" },
	};
#>

	partial class JniRuntime {

		static readonly KeyValuePair<Type, JniTypeSignature>[] JniBuiltinTypeNameMappings = new []{
			new KeyValuePair<Type, JniTypeSignature>(typeof (string),    new JniTypeSignature ("java/lang/String")),

			new KeyValuePair<Type, JniTypeSignature>(typeof (void),      new JniTypeSignature ("V", arrayRank: 0, keyword: true)),
			new KeyValuePair<Type, JniTypeSignature>(typeof (void),      new JniTypeSignature ("java/lang/Void")),

<#
	foreach (var type in types) {
#>
			new KeyValuePair<Type, JniTypeSignature>(typeof (<#= type.Type #>),     new JniTypeSignature ("<#= type.JniType #>", 0, keyword: true)),
			new KeyValuePair<Type, JniTypeSignature>(typeof (<#= type.Type #>),     new JniTypeSignature ("java/lang/<#= type.Name #>")),
<#
	}
#>
		};

		static readonly KeyValuePair<Type, JniMarshalInfo>[] JniBuiltinMarshalers = new []{
			new KeyValuePair<Type, JniMarshalInfo>(typeof (string), new JniMarshalInfo {
				GetValueFromJni             = JniEnvironment.Strings.ToString,
				CreateLocalRef              = JniEnvironment.Strings.NewString,
			}),
<#
	foreach (var type in types) {
#>
			new KeyValuePair<Type, JniMarshalInfo>(typeof (<#= type.Type #>), new JniMarshalInfo {
				CreateJValue                = Jni<#= type.Name #>.CreateJValue,
				GetValueFromJni             = Jni<#= type.Name #>.GetValueFromJni,
				CreateLocalRef              = Jni<#= type.Name #>.CreateLocalRef,
			}),
<#
	}
#>
		};
	}
<#
	foreach (var type in types) {
#>

	static class Jni<#= type.Name #> {
		internal    const   string  JniTypeName = "java/lang/<#= type.Name #>";

		static JniType _TypeRef;
		static JniType TypeRef {
			get {return JniType.GetCachedJniType (ref _TypeRef, JniTypeName);}
		}

		internal static JValue CreateJValue (object value)
		{
			return new JValue ((<#= type.Type #>) value);
		}

		static JniInstanceMethodInfo init;
		internal static unsafe JniObjectReference CreateLocalRef (object value)
		{
			Debug.Assert (value is <#= type.Type #>, "Expected value of type `<#= type.Type #>`; was: " + (value == null ? "<null>" : value.GetType ().FullName));

			var args    = stackalloc JValue [1];
			args [0]    = new JValue ((<#= type.Type #>) value);

			TypeRef.GetCachedConstructor (ref init, "(<#= type.JniType #>)V");
			return TypeRef.NewObject (init, args);
		}

		static JniInstanceMethodInfo <#= type.GetValue #>;
		internal static object GetValueFromJni (ref JniObjectReference self, JniObjectReferenceOptions transfer, Type targetType)
		{
			Debug.Assert (targetType == null || targetType == typeof (<#= type.Type #>), "Expected targetType==typeof(<#= type.Type #>); was: " + targetType);
			TypeRef.GetCachedInstanceMethod (ref <#= type.GetValue #>, "<#= type.GetValue #>", "()<#= type.JniType #>");
			try {
				return <#= type.GetValue #>.InvokeVirtual<#= type.Type #>Method (self);
			} finally {
				JniEnvironment.References.Dispose (ref self, transfer);
			}
		}
	}
<#
	}
#>
}
