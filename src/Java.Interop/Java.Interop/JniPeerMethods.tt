<#@ template  language="C#" #>
<#@ assembly  name="System.Core" #>
<#@ import    namespace="System.Collections.Generic" #>
<#@ import    namespace="System.Linq" #>
<#@ import    namespace="System.Text" #>
<#
	var jniReturnTypes = new[]{
		new { JniCallType   = "Void",       ReturnType  = "void" },
		new { JniCallType   = "Boolean",    ReturnType  = "bool" },
		new { JniCallType   = "SByte",      ReturnType  = "sbyte" },
		new { JniCallType   = "Character",  ReturnType  = "char" },
		new { JniCallType   = "Int16",      ReturnType  = "short" },
		new { JniCallType   = "Int32",      ReturnType  = "int" },
		new { JniCallType   = "Int64",      ReturnType  = "long" },
		new { JniCallType   = "Single",     ReturnType  = "float" },
		new { JniCallType   = "Double",     ReturnType  = "double" },
		new { JniCallType   = "Object",     ReturnType  = "JniObjectReference" },
	};

#>
using System;

namespace Java.Interop.GenericMarshaler {

	public static partial class JniPeerInstanceMethodsExtensions {
<#
	for (int i = 1; i <= 16; ++i ) {
		string typeParams   = i == 1
			? "T"
			: string.Join (", ", Enumerable.Range (1, i)
			.Select (v => "T" + v));
		string methodParams = i == 1
			? "T value"
			: string.Join (", ", Enumerable.Range (1, i)
			.Select (v => "T" + v + " value" + v));
		string methodArgs = i == 1
			? "value"
			: string.Join (", ", Enumerable.Range (1, i)
			.Select (v => "value" + v));
		if (i == 0) {
			typeParams = "";
			methodParams = "";
		} else {
			typeParams = "<" + typeParams + ">";
		}
#>

		public static JniObjectReference StartGenericCreateInstance<#= typeParams #> (
			this    JniPeerInstanceMethods peer,
			string  constructorSignature,
			Type    declaringType,
			<#= methodParams #>
		)
		{
			if (JniEnvironment.Current.JavaVM.NewObjectRequired) {
				return NewObject (peer, constructorSignature, declaringType, <#= methodArgs #>);
			}
			return peer.AllocObject (declaringType);
		}

		static unsafe JniObjectReference NewObject<#= typeParams #> (
			JniPeerInstanceMethods  peer,
		    string  constructorSignature,
		    Type    declaringType,
		    <#= methodParams #>
		)
		{
<#
		for (int a = 1; a <= i; ++a) {
		    WriteLine ("\t\t\tJniArgumentMarshalInfo<{0}> arg{1} = new JniArgumentMarshalInfo<{0}>(value{1});",
		            i == 1 ? "T" : "T" + a,
		            i == 1 ? "" : a.ToString ());
		}
		WriteLine ("");
		WriteLine ("\t\t\tvar args = stackalloc JValue [{0}];", i);
		for (int a = 1; a <= i; ++a) {
		    WriteLine ("\t\t\targs [{0}] = arg{1}.JValue;",
					a - 1,
		            i == 1 ? "" : a.ToString ());
		}
		WriteLine ("");
#>
			try {
			    return peer.NewObject (constructorSignature, declaringType, args);
			} finally {
<#
		for (int a = 1; a <= i; ++a) {
		    WriteLine ("\t\t\t\targ{0}.Cleanup (value{0});",
		            i == 1 ? "" : a.ToString ());
		}
#>
			}
		}

		public static void FinishGenericCreateInstance<#= typeParams #> (
			this        JniPeerInstanceMethods  peer,
		    string      constructorSignature,
		    IJavaPeerable   self,
		    <#= methodParams #>
		)
		{
			if (JniEnvironment.Current.JavaVM.NewObjectRequired) {
				return;
			}
			_InvokeConstructor (peer, constructorSignature, self, <#= methodArgs #>);
		}

		static unsafe void _InvokeConstructor<#= typeParams #> (
			JniPeerInstanceMethods  peer,
		    string      constructorSignature,
		    IJavaPeerable   self,
		    <#= methodParams #>
		)
		{
<#
		for (int a = 1; a <= i; ++a) {
		    WriteLine ("\t\t\tJniArgumentMarshalInfo<{0}> arg{1} = new JniArgumentMarshalInfo<{0}>(value{1});",
		            i == 1 ? "T" : "T" + a,
		            i == 1 ? "" : a.ToString ());
		}
		WriteLine ("");
		WriteLine ("\t\t\tvar args = stackalloc JValue [{0}];", i);
		for (int a = 1; a <= i; ++a) {
		    WriteLine ("\t\t\targs [{0}] = arg{1}.JValue;",
					a - 1,
		            i == 1 ? "" : a.ToString ());
		}
		WriteLine ("");
#>
			try {
				var methods = peer.GetConstructorsForType (self.GetType ());
				var ctor    = methods.GetConstructor (constructorSignature);
				ctor.InvokeNonvirtualVoidMethod (self.PeerReference, methods.JniPeerType.PeerReference, args);
			} finally {
<#
		for (int a = 1; a <= i; ++a) {
		    WriteLine ("\t\t\t\targ{0}.Cleanup (value{0});",
		            i == 1 ? "" : a.ToString ());
		}
#>
			}
		}
<#
	}
	foreach (var info in jniReturnTypes) {
		string ret = "";
		if (info.ReturnType != "void") {
		    ret = "return ";
		}

#>
<#
	}
#>
<#
	foreach (var info in jniReturnTypes) {
		string ret = "";
		if (info.ReturnType != "void") {
		    ret = "return ";
		}

#>
<#
		for (int i = 0; i <= 16; ++i ) {
			string typeParams   = i == 1
				? "T"
				: string.Join (", ", Enumerable.Range (1, i)
				.Select (v => "T" + v));
			string methodParams = i == 1
				? "T value"
				: string.Join (", ", Enumerable.Range (1, i)
				.Select (v => "T" + v + " value" + v));
			if (i == 0) {
				typeParams = "";
				methodParams = "";
			} else {
				typeParams = "<" + typeParams + ">";
			}
#>

		public static unsafe <#= info.ReturnType #> InvokeGenericVirtual<#= info.JniCallType #>Method<#= typeParams #> (
			this    JniPeerInstanceMethods peer,
			string encodedMember,
			IJavaPeerable   self<#= i == 0 ? "" : ",\n\t\t\t" + methodParams #>
		)
		{
<#
			for (int a = 1; a <= i; ++a) {
			    WriteLine ("\t\t\tJniArgumentMarshalInfo<{0}> arg{1} = new JniArgumentMarshalInfo<{0}>(value{1});",
			            i == 1 ? "T" : "T" + a,
			            i == 1 ? "" : a.ToString ());
			}
			WriteLine ("");
			WriteLine ("\t\t\tvar args = stackalloc JValue [{0}];", i);
			for (int a = 1; a <= i; ++a) {
			    WriteLine ("\t\t\targs [{0}] = arg{1}.JValue;",
						a - 1,
			            i == 1 ? "" : a.ToString ());
			}
			WriteLine ("");
#>
			try {
				<#= ret #>peer.InvokeVirtual<#= info.JniCallType #>Method (encodedMember, self, args);
			} finally {
<#
			for (int a = 1; a <= i; ++a) {
			    WriteLine ("\t\t\t\targ{0}.Cleanup (value{0});",
			            i == 1 ? "" : a.ToString ());
			}
#>
			}
		}
<#
		}
	}
#>
	}

	public static partial class JniPeerStaticMethodsExtensions {

<#
	foreach (var info in jniReturnTypes) {
		string ret = "";
		if (info.ReturnType != "void") {
		    ret = "return ";
		}

#>
<#
		for (int i = 1; i <= 16; ++i ) {
			string typeParams   = i == 1
				? "T"
				: string.Join (", ", Enumerable.Range (1, i)
				.Select (v => "T" + v));
			string methodParams = i == 1
				? "T value"
				: string.Join (", ", Enumerable.Range (1, i)
				.Select (v => "T" + v + " value" + v));
			if (i == 0) {
				typeParams = "";
				methodParams = "";
			} else {
				typeParams = "<" + typeParams + ">";
			}
#>

		public static unsafe <#= info.ReturnType #> InvokeGeneric<#= info.JniCallType #>Method<#= typeParams #> (
		    this    JniPeerStaticMethods    peer,
			string encodedMember<#= i == 0 ? "" : ",\n\t\t\t" + methodParams #>
		)
		{
<#
			for (int a = 1; a <= i; ++a) {
			    WriteLine ("\t\t\tJniArgumentMarshalInfo<{0}> arg{1} = new JniArgumentMarshalInfo<{0}>(value{1});",
			            i == 1 ? "T" : "T" + a,
			            i == 1 ? "" : a.ToString ());
			}
			WriteLine ("");
			WriteLine ("\t\t\tvar args = stackalloc JValue [{0}];", i);
			for (int a = 1; a <= i; ++a) {
			    WriteLine ("\t\t\targs [{0}] = arg{1}.JValue;",
						a - 1,
			            i == 1 ? "" : a.ToString ());
			}
			WriteLine ("");
#>
			try {
				<#= ret #>peer.Invoke<#= info.JniCallType #>Method (encodedMember, args);
			} finally {
<#
			for (int a = 1; a <= i; ++a) {
			    WriteLine ("\t\t\t\targ{0}.Cleanup (value{0});",
			            i == 1 ? "" : a.ToString ());
			}
#>
			}
		}
<#
		}
	}
#>
	}
}
